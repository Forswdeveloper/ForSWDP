람다 표현식.


람다와 함수형(기능적) 인터페이스.(기능이 하나인,추상메소드가 하나인 인터페이스)

- 구현해야 할 추상메소드가 하나인 인터페이스

인스턴스보다 기능 하나가 필요한 상황을 위한 람다   -> 기능 하나 ( 메소드 하나)
class SLenComp implements Comparator<String>{
  @Override
  public int compare(String s1, STring s2){
    return s1.length() - s2.length();
  }
}

List<String> list = new ArrayList<>();
list.add("Robot");
list.add("Toy");
list.add("Box");

Collections.sort(list, new SLenComp());   // Collections.sort는 정렬 대상 뿐만아니라 정렬의 기준을 가진 기능도 필요로한다.

for(String s : list)
  System.out.println();


매개변수가 있고 반환하지 않는 람다식

interface Printagel{
  void print(Strig s);   // 매개변수 하나, 반환형 void
}

Printable P;
p = (String s) -> {System.out.println(s);};  // 줄임 없는 표현.
p.print("Lambda exp one.");

p = (String s) -> System.out.println(s);  // 중괄호 생략.
p.print("Lambda exp two.");

p = (s) -> System.out.println(s); // 매개변수 형 생략
p.print("Lambda exp three.");

p = s -> System.out.println(s); // 매개변수 소괄호 생략.
p.print("Lambda exp four.");

메소드 몸체가 둘 이상의 문장으로 이뤄져 있거나,
매개변수의 수가 둘 이상인 경우에는 각각 중괄호와 소괄호의 생략이 불가능하다.


매개변수가 둘 인 람다식

interface Calculate(
  void cal(int a, int b); // 매개변수 둘 , 반환형 void
}
Calculate c;
c = (a,b) -> System.out.println(a+b);
c.cal(4,3);

c = (a,b) -> System.out.println(a-b);
c.cal(4,3);

c = (a,b) -> System.out.println(a*b);
c.cal(4,3);


매개변수가 있고 반환하는 람다식1

interface Calculate{
  int cal(int a, int b); // 값을 반환하는 추상 메소드
}

Calculate c;
c = (a,b) -> {return a+b;};  //return문의 중괄호는 생략 불가.
System.out.println(c.ca(4.3));   

c = (a,b) -> a+b;  //연산 결과가 남으면, 별도로 명시하지 않아도 반환 대상이 됨.
System.out.println(c.cal(4,3)); 

매개변수가 있고 반환하는 람다식2

interface HowLong{
  int len(String s);
}
HowLong h1 = s -> s.length();   -> 값이 남아서 return 생략 가능.
System.out.println(hl.len("I am so happy"));


매개변수가 없는 람다식

interface Generate{
  int rand();
}
Generator gen = () ->{     // 매개변수가 없을 경우 없다고 명시를 해주어야 한다.
  Random rand = new Random();
  return rand.nextInt(50);
 }


함수형 인터페이스와 어노테이션.

@FunctionalInterfae
-> 함수형 인터페이스의 조건을 갖추었는지에 대한 검사를 컴파일러에게 요청.

@FunctionalInterface        
interface Calculate{
  int cal(int a, int b)
}

@FunctionalInterface
interface Calculate{
  int cal(int a, int b);
  default int add(int a, int b) {return a+b;}
  static int sub(int a, int b) {return a-b;}
}
추상 메소드가 하나이니, 함수형 인터페이스 조건에 부합.



람다식과 제네릭

@FunctionalInterface
interface Calculate <T>{
  T cal(T a, T b);
}
Calculate<Integer> ci = (a,b) -> a+b;
System.out.println(ci.cal(4,3));

Calculate<Double> cd = (a,b) -> a+b;
System.out.println(cd.cal(4.32,3.45));




미리 정의되어 있는 함수형 인터페이스.

default boolean removeIf(Predicate<? super E> filter)  <- 람다 식을 전달해야함. 추상 메소드가 무엇인지만 알면 됌.
-> Collection<E> 인터페이스에 정의되어 있는 디폴트 메소드.

Predicate 인터페이스의 추상 메소드는 다음과 같이 정의해 두었다.            @FunctionalInterface
  boolean test(T t);                                                   public interface Predicate<T>{
                                                                            boolean test(T t): 
                                                                       }
미리 정의해 두었으므로 Predicate라는 이름만으로 통한다!



미리 정의해둔 대표 인터페이스

Predicate<T>      boolean test(T t)
                    전달 인자를 근거로 참 또는 거짓을 반환
Supplier<T>       T get()
                    메소드 호출 시 무엇인가를 제공함
Consumer<T>       void accept(T t)
                    무엇인자를 받아 들이기만 함
Function<T,R>     R apply(T t)
                  입출력 출력이 있음(수학적으로는 함수)

