람다 표현식.


람다와 함수형(기능적) 인터페이스.(기능이 하나인,추상메소드가 하나인 인터페이스)

- 구현해야 할 추상메소드가 하나인 인터페이스

인스턴스보다 기능 하나가 필요한 상황을 위한 람다   -> 기능 하나 ( 메소드 하나)
class SLenComp implements Comparator<String>{
  @Override
  public int compare(String s1, STring s2){
    return s1.length() - s2.length();
  }
}

List<String> list = new ArrayList<>();
list.add("Robot");
list.add("Toy");
list.add("Box");

Collections.sort(list, new SLenComp());   // Collections.sort는 정렬 대상 뿐만아니라 정렬의 기준을 가진 기능도 필요로한다.

for(String s : list)
  System.out.println();


매개변수가 있고 반환하지 않는 람다식

interface Printagel{
  void print(Strig s);   // 매개변수 하나, 반환형 void
}

Printable P;
p = (String s) -> {System.out.println(s);};  // 줄임 없는 표현.
p.print("Lambda exp one.");

p = (String s) -> System.out.println(s);  // 중괄호 생략.
p.print("Lambda exp two.");

p = (s) -> System.out.println(s); // 매개변수 형 생략
p.print("Lambda exp three.");

p = s -> System.out.println(s); // 매개변수 소괄호 생략.
p.print("Lambda exp four.");

메소드 몸체가 둘 이상의 문장으로 이뤄져 있거나,
매개변수의 수가 둘 이상인 경우에는 각각 중괄호와 소괄호의 생략이 불가능하다.


매개변수가 둘 인 람다식

interface Calculate(
  void cal(int a, int b); // 매개변수 둘 , 반환형 void
}
Calculate c;
c = (a,b) -> System.out.println(a+b);
c.cal(4,3);

c = (a,b) -> System.out.println(a-b);
c.cal(4,3);

c = (a,b) -> System.out.println(a*b);
c.cal(4,3);


매개변수가 있고 반환하는 람다식1

interface Calculate{
  int cal(int a, int b); // 값을 반환하는 추상 메소드
}

Calculate c;
c = (a,b) -> {return a+b;};  //return문의 중괄호는 생략 불가.
System.out.println(c.ca(4.3));   

c = (a,b) -> a+b;  //연산 결과가 남으면, 별도로 명시하지 않아도 반환 대상이 됨.
System.out.println(c.cal(4,3)); 

매개변수가 있고 반환하는 람다식2

interface HowLong{
  int len(String s);
}
HowLong h1 = s -> s.length();   -> 값이 남아서 return 생략 가능.
System.out.println(hl.len("I am so happy"));


매개변수가 없는 람다식

interface Generate{
  int rand();
}
Generator gen = () ->{     // 매개변수가 없을 경우 없다고 명시를 해주어야 한다.
  Random rand = new Random();
  return rand.nextInt(50);
 }


함수형 인터페이스와 어노테이션.

@FunctionalInterfae
-> 함수형 인터페이스의 조건을 갖추었는지에 대한 검사를 컴파일러에게 요청.

@FunctionalInterface        
interface Calculate{
  int cal(int a, int b)
}

@FunctionalInterface
interface Calculate{
  int cal(int a, int b);
  default int add(int a, int b) {return a+b;}
  static int sub(int a, int b) {return a-b;}
}
추상 메소드가 하나이니, 함수형 인터페이스 조건에 부합.



람다식과 제네릭

@FunctionalInterface
interface Calculate <T>{
  T cal(T a, T b);
}
Calculate<Integer> ci = (a,b) -> a+b;
System.out.println(ci.cal(4,3));

Calculate<Double> cd = (a,b) -> a+b;
System.out.println(cd.cal(4.32,3.45));




미리 정의되어 있는 함수형 인터페이스.

default boolean removeIf(Predicate<? super E> filter)  <- 람다 식을 전달해야함. 추상 메소드가 무엇인지만 알면 됌.
-> Collection<E> 인터페이스에 정의되어 있는 디폴트 메소드.

Predicate 인터페이스의 추상 메소드는 다음과 같이 정의해 두었다.            @FunctionalInterface
  boolean test(T t);                                                   public interface Predicate<T>{
                                                                            boolean test(T t): 
                                                                       }
미리 정의해 두었으므로 Predicate라는 이름만으로 통한다!



미리 정의해둔 대표 인터페이스

java.util.function 패키지로 묶여 있음.

Predicate<T>      boolean test(T t)
                    전달 인자를 근거로 참 또는 거짓을 반환
Supplier<T>       T get()
                    메소드 호출 시 무엇인가를 제공함 
Consumer<T>       void accept(T t)
                    무엇인자를 받아 들이기만 함 
Function<T,R>     R apply(T t)
                  입출력 출력이 있음(수학적으로는 함수)



Predicate<T>
boolean test(T t);

public static int sum<Predicate<Integer> p, List<Integer> list){
  int s = 0;
  for(int n : list){
    if(p.test(n))     // 전달해준 메소드에 따라서 참과 거짓을 판별
      s+=n;
  }]
  return s;
}
List<Integer> list = Arrays.asList(1,5,7,9,11,12);
int s;
s = sum(n-> n%2 == 0, list);       // list에서 값을 하나씩 꺼내서 문장으로 전달될때 문장이 실행된다.
System.out.println("짝수 합 : " + s);

s = sum(n-> n%2 != 0, list);
System.out.println("홀수 합 : " + s);


Predicate<T>를 구체화하고 다양화 한 인터페이스들.

IntPredicate       boolean test(int value)
LongPredicate      boolean test(long value)
DoublePredicate    boolean test(double value)
Bipredicate<T,U>   boolean test(T t, U u)  -> 2가지 정보를 가지고 참 거짓을 판별.


public static int sum(Predicate<Integer> p, List<Integer> list){...}
                            ↓
public static int sum(IntPredicate p, List<Integer> list){...}
    대체 가능! 그리고 박싱, 언박싱 과정이 필요 없어짐.





Supplier<T>
T get();

                                                이 메소드가 호출될 때마다 난수가 생성됨.
public static List<Integer> makeIntList(Supplier<Integer> s, int n){
  List<Integer> list = new ArrayList<>();
  for(int i = 0 ; i < n ; i++)
      list.add(s.get());    /// 난수를 생성해 담는다.
  return list;
}

Supplier<Integer> spr = () ->{
  Random rand = new Random();
  reeturn rand.nextInt(50);
};
List<Integer> list = makeIntList(spr, 5);
System.out.println(list);

list = makeIntList(spr, 10);
System.out.println(list);


Supplier<T>를 구체화 한 인터페이스들

IntSupplier        int getAsInt()
LongSupplier       long getAsLong()
DoubleSupplier     double getAsDouble()
BooleanSupplier    boolean getAsBoolean()

public static List<Integer> makeIntList(Supplier<Integer> s, int n){......}
                            ↓
public static List<Integer> makeIntList(IntSupplier s, int n){......}
              대체 가능! 그리고 박싱, 언박싱 과정이 필요 없어짐.


Consumer<T>
void accept(T t);      반환 없고 전달 인자만.


Consumer<String> c = s -> System.out.println(s);
c.accept("Pineapple");      // 출력이라는 결과를 보임.
c.accept("Struawberry");


Consumer<T>를 구체화하고 다양화 한 인터페이스들

IntConsumer             void accept(int value)
ObjIntConsumer<T>       void accept(T t, int value)

LongConsumer            void accept(long value)
ObjLongConsumer<T>      void accept(T t, long value)

DoubleConsumer          void accept(double value)
ObjDoubleConsumer<T>    void accept(T t, double value)

BiConsumer<T,U>         void accept(T t, U u)   두개의 인스턴스를 소모하겠다.


Consumer<String> c = s -> System.out.println(s);
ObjIntConsumer<String> c = (s,i) -> System.out.println(i + "." + s);



Function<T,R>   <매개변수형, 반환형>    들어오고, 나가고
R apply(T t);

Function<String, Integer> f = s -> s.length();
System.out.println(f.apply("Robot"));
System.out.println(f.apply("System"));

